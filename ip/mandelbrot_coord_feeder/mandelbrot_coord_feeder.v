// Copyright (c) 2017 Intel Corporation
// SPDX-License-Identifier: MIT

`timescale 1 ps / 1 ps

// This core takes an input vector generated by the mandelbrot_image_feeder core
// and creates an msgdma descriptor for the work load.  It pushes the descriptor
// into an msgdma controller and then it proceeds to process the coordinate run
// length described in the input vector by passing each coordinate into an
// avst_mandelbrot_engine core and retrieving the result.  It then passes the
// results into the data sink of the msgdma core to be written to memory.
// 
// Optionally a mandelbrot_colorizer core can be placed between this core and
// the msgdma data sink in order to apply colorization to the result values.

module mandelbrot_coord_feeder(

	// clock and reset for component
	input  wire        clk,
	input  wire        reset,

	// avst sink interface, in_vector
	// this is a multi-data vector containing:
	// pix_buf_ptr[31:0] @ snk_data[151:120]
	//  line_count[ 7:0] @ snk_data[119:112]
	//    step_dim[31:0] @ snk_data[111: 80]
	//   max_iters[15:0] @ snk_data[ 79: 64]
	//          cr[31:0] @ snk_data[ 63: 32]
	//          ci[31:0] @ snk_data[ 31: 0]
	input  wire [151:0] in_vector_snk_data,
	input  wire         in_vector_snk_valid,
	output wire         in_vector_snk_ready,

	// avst source interface, out_descriptor
	// this is an msgdma descriptor
	output wire [255:0] out_descriptor_src_data,
	output wire         out_descriptor_src_valid,
	input  wire         out_descriptor_src_ready,

	// avst sink interface, in_response
	// this is an msgdma response
	input  wire [255:0] in_response_snk_data,
	input  wire         in_response_snk_valid,
	output wire         in_response_snk_ready,

	// avst source interface, out_vector
	// this is a multi-data vector containing:
	// max_iters[15:0] @ src_data[79:64]
	//        cr[31:0] @ src_data[63:32]
	//        ci[31:0] @ src_data[31:0]
	output wire [ 79:0] out_vector_src_data,
	output wire         out_vector_src_valid,
	input  wire         out_vector_src_ready,

	// avst sink interface, in_result
	input  wire [ 15:0] in_result_snk_data,
	input  wire         in_result_snk_valid,
	output wire         in_result_snk_ready,

	// avst source interface, out_pixel
	output wire [ 31:0] out_pixel_src_data,
	output wire         out_pixel_src_valid,
	input  wire         out_pixel_src_ready
);

localparam STATE_IDLE        = 2'b00;
localparam STATE_LOAD_DESC   = 2'b01;
localparam STATE_FEED_COORDS = 2'b10;

wire [31:0] v_ci;
wire [31:0] v_cr;
wire [15:0] v_max_iters;
wire [31:0] v_step_dim;
wire [ 7:0] v_line_count;
wire [31:0] v_pix_buf_ptr;

reg  [31:0] ci;
reg  [31:0] cr;
reg  [15:0] max_iters;
reg  [31:0] step_dim;
reg  [ 7:0] line_count;
reg  [31:0] pix_buf_ptr;

reg  [ 1:0] state;
reg  [10:0] pixel_count;
reg  [10:0] started_count;
reg  [10:0] complete_count;
reg         holding_result;
reg  [15:0] result;
reg  [31:0] dma_length;

assign {
	v_pix_buf_ptr,
	v_line_count,
	v_step_dim,
	v_max_iters,
	v_cr,
	v_ci
} = {
	in_vector_snk_data[151:120],
	in_vector_snk_data[119:112],
	in_vector_snk_data[111: 80],
	in_vector_snk_data[79:64],
	in_vector_snk_data[63:32],
	in_vector_snk_data[31:0]
};

// in_vector
assign in_vector_snk_ready = (state == STATE_IDLE) ?
				(1'b1) : (1'b0);

// out_descriptor
assign out_descriptor_src_valid = (state == STATE_LOAD_DESC) ?
					(1'b1) : (1'b0);

// MSGDMA WRITE MASTER DESCRIPTOR INPUT FORMAT
//
// THIS IS THE RAW HDL DEFINITION OF THE COMMAND DESCRIPTOR INPUT VECTOR
//
// descriptor_address = {snk_command_data[123:92], snk_command_data[31:0]};
// descriptor_length = snk_command_data[63:32];
// descriptor_programmable_burst_count = snk_command_data[75:68];
// descriptor_stride = snk_command_data[91:76];
// descriptor_end_on_eop_enable = snk_command_data[64];
// sw_stop_in = snk_command_data[66];
// sw_reset_in = snk_command_data[67];
//
// TO VISUALIZE THIS A BIT EASIER, SOME ASCII ART
//
// |255--128|
// These 16 bytes from bits 255 through 128 are not used, so set them to ZERO.
//
// |127--120|119--112|111--104|103---96|95----88|87----80|79----72|71----64|
//      ++++ ++++++++ ++++++++ ++++++++ ++++++++ ++++++++ ++++++++ ++++++ +
//      |--------address[123:92]-----------||--stride[91:76]-||---.---||| |
//                                                                |    || |
//                             programmable_burst_count[75:68]  --+    || |
//                                                   sw_reset_in[67] --+| |
//                                                     sw_stop_in[66] --+ |
//                                                end_on_eop_enable[64] --+
//
// |63----56|55----48|47----40|39----32|31----24|23----16|15-----8|7------0|
//  ++++++++ ++++++++ ++++++++ ++++++++ ++++++++ ++++++++ ++++++++ ++++++++
//  |---------length[63:32]-----------| |----------address[31:0]----------|

assign out_descriptor_src_data = {
	{128{1'b0}},	// unused[255:128]
	{4{1'b0}},	// unused[127:124]
	{32{1'b0}},	// address[123:92]
	{16{1'b0}},	// stride[91:76]
	line_count,	// programmable_burst_count[75:68]
	1'b0,		// sw_reset_in[67]
	1'b0,		// sw_stop_in[66]
	1'b0,		// unused[65]
	1'b0,		// end_on_eop_enable[64]
	dma_length,	// length[63:32]
	pix_buf_ptr	// address[31:0]
};

// in_response
assign in_response_snk_ready = 1'b1;

// out_vector
assign out_vector_src_valid = ((state == STATE_FEED_COORDS) &&
				(started_count < pixel_count)) ?
				(1'b1) : (1'b0);

assign out_vector_src_data = {max_iters, cr, ci};

// in_result
assign in_result_snk_ready = ((state == STATE_FEED_COORDS) &&
				(~holding_result)) ?
				(1'b1) : (1'b0);

// out_pixel
assign out_pixel_src_valid = ((state == STATE_FEED_COORDS) &&
				(holding_result)) ?
				(1'b1) : (1'b0);

assign out_pixel_src_data = {result[7:0], result[15:8], 8'h00, 8'h00};

always @ (posedge clk or posedge reset) begin
if(reset) begin
	ci <= 32'd0;
	cr <= 32'd0;
	max_iters <= 16'd0;
	step_dim <= 32'd0;
	line_count <= 8'd0;
	pix_buf_ptr <= 32'd0;

	pixel_count <= 10'h0;
	started_count <= 10'h0;
	complete_count <= 10'h0;
	holding_result <= 1'b0;
	result <= 16'h0;
	dma_length <= 32'h0;
	state <= STATE_IDLE;

end else begin

	case(state)
	STATE_IDLE: begin
		ci <= v_ci;
		cr <= v_cr;
		max_iters <= v_max_iters;
		step_dim <= v_step_dim;
		line_count <= v_line_count;
		pix_buf_ptr <= v_pix_buf_ptr;

		pixel_count <= {v_line_count, 3'b000};
		started_count <= 10'h0;
		complete_count <= 10'h0;
		holding_result <= 1'b0;
		result <= 16'h0;
		dma_length <= {v_line_count, 5'b00000};

		if(in_vector_snk_valid & in_vector_snk_ready) begin
			state <= STATE_LOAD_DESC;
		end
	end
	STATE_LOAD_DESC: begin

		if(out_descriptor_src_valid & out_descriptor_src_ready) begin
			state <= STATE_FEED_COORDS;
		end
	end
	STATE_FEED_COORDS: begin

		if(out_vector_src_valid & out_vector_src_ready) begin
			started_count <= started_count + 1'b1;
			cr <= cr + step_dim;
		end

		if(in_result_snk_valid & in_result_snk_ready) begin
			holding_result <= 1'b1;
			result <= in_result_snk_data;
		end

		if(out_pixel_src_valid & out_pixel_src_ready) begin
			holding_result <= 1'b0;
			complete_count <= complete_count + 1'b1;
		end

		if(complete_count == pixel_count) begin
			state <= STATE_IDLE;
		end
	end
	endcase

end // if
end // always

endmodule

